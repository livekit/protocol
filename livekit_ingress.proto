syntax = "proto3";

package livekit;

import "livekit_models.proto";

option go_package = "github.com/livekit/protocol/livekit";
option csharp_namespace = "LiveKit.Proto";
option ruby_package = "LiveKit::Proto";

service Ingress {
    // Create a new Ingress
    rpc CreateIngress(CreateIngressRequest) returns (IngressInfo);
    // Update an existing Ingress. Ingress can only be updated when it's in ENDPOINT_WAITING state.
    rpc UpdateIngress(UpdateIngressRequest) returns (IngressInfo);
    rpc ListIngress(ListIngressRequest) returns (ListIngressResponse);
    rpc StopIngress(StopIngressRequest) returns (IngressInfo);
}

message CreateIngressRequest {
    IngressInput input_type = 1;
    // User provided identifier for the ingress
    string name = 2;
    // room to publish to
    string room_name = 3;
    // publish as participant
    string participant_identity = 4;
    // name of publishing participant (used for display only)
    string participant_name = 5;
    IngressAudioOptions audio = 6;
    IngressVideoOptions video = 7;
    // when true, ingress will be re-used after completion.
    // it'll will return to ENDPOINT_WAITING after the stream has finished (or failed)
    // this is useful to keep the same Ingress URL for future ingestion
    bool reuse = 8;
}

enum IngressInput {
    RTMP_INPUT = 0;
    //    FILE_INPUT = 1;
    //    SRT_INPUT = 2;
    //    URL_INPUT = 3;
}

message IngressAudioOptions {
    string name = 1;
    TrackSource source = 2;
    // desired mime_type to publish to room
    string mime_type = 3;
    uint32 bitrate = 4;
    bool disable_dtx = 5;
    uint32 channels = 6;
}

message IngressVideoOptions {
    string name = 1;
    TrackSource source = 2;
    // desired mime_type to publish to room
    string mime_type = 3;
    // simulcast layers to publish, when empty, it'll pick default simulcast
    // layers at 1/2 and 1/4 of the dimensions
    repeated VideoLayer layers = 4;
}

message IngressInfo {
    enum Status {
        ENDPOINT_WAITING = 0;
        ENDPOINT_ACTIVE = 1;
        ENDPOINT_PUBLISHING = 2;
        ENDPOINT_ERROR = 3; // Received Stream is invalid
    }
    string ingress_id = 1;
    string name = 2;
    string stream_key = 11;
    IngressInput input_type = 3;
    Status status = 4;
    InputStatus input_status = 5; // Description of error/stream non compliance and debug info for publisher otherwise (received bitrate, resolution, bandwidth)
    string room = 6;
    string participant_identity = 7;
    string participant_name = 8;
    // for RTMP input, it'll be a rtmp:// URL
    // for FILE input, it'll be a http:// URL
    // for SRT input, it'll be a srt:// URL
    string url = 9;
    repeated TrackInfo tracks = 10;
}

message InputStatus {
    string status_description = 1; // Error/non compliance description if any
    InputVideoStatus video = 2;
    InputAudioStatus audio = 3;
}

message InputVideoStatus {
    uint32 mime_type = 1;
    uint32 bitrate = 2;
    uint32 width = 3;
    uint32 height = 4;
    uint32 framerate = 5;
}

message InputAudioStatus {
    uint32 mime_type = 1;
    uint32 bitrate = 2;
    uint32 channels = 3;
    uint32 sample_rate = 4;
}

message UpdateIngressRequest {
    string ingress_id = 1;
    string name = 2;
    string room_name = 3;
    string participant_identity = 4;
    string participant_name = 5;
    IngressAudioOptions audio = 6;
    IngressVideoOptions video = 7;
}

message ListIngressRequest {
    // when blank, lists all ingress endpoints
    string room = 1;
}

message ListIngressResponse {
    repeated IngressInfo items = 1;
}

message StopIngressRequest {
    string ingress_id = 1;
}
