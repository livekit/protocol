// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file livekit_metrics.proto (package livekit, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * index from [0: MAX_LABEL_PREDEFINED_MAX_VALUE) are for predefined labels (`MetricLabel`)
 *
 * @generated from enum livekit.MetricLabel
 */
export enum MetricLabel {
  /**
   * time to first token from LLM
   *
   * @generated from enum value: AGENTS_LLM_TTFT = 0;
   */
  AGENTS_LLM_TTFT = 0,

  /**
   * time to final transcription
   *
   * @generated from enum value: AGENTS_STT_TTFT = 1;
   */
  AGENTS_STT_TTFT = 1,

  /**
   * time to first byte
   *
   * @generated from enum value: AGENTS_TTS_TTFB = 2;
   */
  AGENTS_TTS_TTFB = 2,

  /**
   * Number of video freezes
   *
   * @generated from enum value: CLIENT_VIDEO_SUBSCRIBER_FREEZE_COUNT = 3;
   */
  CLIENT_VIDEO_SUBSCRIBER_FREEZE_COUNT = 3,

  /**
   * total duration of freezes
   *
   * @generated from enum value: CLIENT_VIDEO_SUBSCRIBER_TOTAL_FREEZE_DURATION = 4;
   */
  CLIENT_VIDEO_SUBSCRIBER_TOTAL_FREEZE_DURATION = 4,

  /**
   * number of video pauses
   *
   * @generated from enum value: CLIENT_VIDEO_SUBSCRIBER_PAUSE_COUNT = 5;
   */
  CLIENT_VIDEO_SUBSCRIBER_PAUSE_COUNT = 5,

  /**
   * total duration of pauses
   *
   * @generated from enum value: CLIENT_VIDEO_SUBSCRIBER_TOTAL_PAUSES_DURATION = 6;
   */
  CLIENT_VIDEO_SUBSCRIBER_TOTAL_PAUSES_DURATION = 6,

  /**
   * number of concealed (synthesized) audio samples
   *
   * @generated from enum value: CLIENT_AUDIO_SUBSCRIBER_CONCEALED_SAMPLES = 7;
   */
  CLIENT_AUDIO_SUBSCRIBER_CONCEALED_SAMPLES = 7,

  /**
   * number of silent concealed samples
   *
   * @generated from enum value: CLIENT_AUDIO_SUBSCRIBER_SILENT_CONCEALED_SAMPLES = 8;
   */
  CLIENT_AUDIO_SUBSCRIBER_SILENT_CONCEALED_SAMPLES = 8,

  /**
   * number of concealment events
   *
   * @generated from enum value: CLIENT_AUDIO_SUBSCRIBER_CONCEALMENT_EVENTS = 9;
   */
  CLIENT_AUDIO_SUBSCRIBER_CONCEALMENT_EVENTS = 9,

  /**
   * number of interruptions
   *
   * @generated from enum value: CLIENT_AUDIO_SUBSCRIBER_INTERRUPTION_COUNT = 10;
   */
  CLIENT_AUDIO_SUBSCRIBER_INTERRUPTION_COUNT = 10,

  /**
   * total duration of interruptions
   *
   * @generated from enum value: CLIENT_AUDIO_SUBSCRIBER_TOTAL_INTERRUPTION_DURATION = 11;
   */
  CLIENT_AUDIO_SUBSCRIBER_TOTAL_INTERRUPTION_DURATION = 11,

  /**
   * total time spent in jitter buffer
   *
   * @generated from enum value: CLIENT_SUBSCRIBER_JITTER_BUFFER_DELAY = 12;
   */
  CLIENT_SUBSCRIBER_JITTER_BUFFER_DELAY = 12,

  /**
   * total time spent in jitter buffer
   *
   * @generated from enum value: CLIENT_SUBSCRIBER_JITTER_BUFFER_EMITTED_COUNT = 13;
   */
  CLIENT_SUBSCRIBER_JITTER_BUFFER_EMITTED_COUNT = 13,

  /**
   * total duration spent in bandwidth quality limitation
   *
   * @generated from enum value: CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_BANDWIDTH = 14;
   */
  CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_BANDWIDTH = 14,

  /**
   * total duration spent in cpu quality limitation
   *
   * @generated from enum value: CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_CPU = 15;
   */
  CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_CPU = 15,

  /**
   * total duration spent in other quality limitation
   *
   * @generated from enum value: CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_OTHER = 16;
   */
  CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_OTHER = 16,

  /**
   * @generated from enum value: METRIC_LABEL_PREDEFINED_MAX_VALUE = 4096;
   */
  METRIC_LABEL_PREDEFINED_MAX_VALUE = 4096,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricLabel)
proto3.util.setEnumType(MetricLabel, "livekit.MetricLabel", [
  { no: 0, name: "AGENTS_LLM_TTFT" },
  { no: 1, name: "AGENTS_STT_TTFT" },
  { no: 2, name: "AGENTS_TTS_TTFB" },
  { no: 3, name: "CLIENT_VIDEO_SUBSCRIBER_FREEZE_COUNT" },
  { no: 4, name: "CLIENT_VIDEO_SUBSCRIBER_TOTAL_FREEZE_DURATION" },
  { no: 5, name: "CLIENT_VIDEO_SUBSCRIBER_PAUSE_COUNT" },
  { no: 6, name: "CLIENT_VIDEO_SUBSCRIBER_TOTAL_PAUSES_DURATION" },
  { no: 7, name: "CLIENT_AUDIO_SUBSCRIBER_CONCEALED_SAMPLES" },
  { no: 8, name: "CLIENT_AUDIO_SUBSCRIBER_SILENT_CONCEALED_SAMPLES" },
  { no: 9, name: "CLIENT_AUDIO_SUBSCRIBER_CONCEALMENT_EVENTS" },
  { no: 10, name: "CLIENT_AUDIO_SUBSCRIBER_INTERRUPTION_COUNT" },
  { no: 11, name: "CLIENT_AUDIO_SUBSCRIBER_TOTAL_INTERRUPTION_DURATION" },
  { no: 12, name: "CLIENT_SUBSCRIBER_JITTER_BUFFER_DELAY" },
  { no: 13, name: "CLIENT_SUBSCRIBER_JITTER_BUFFER_EMITTED_COUNT" },
  { no: 14, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_BANDWIDTH" },
  { no: 15, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_CPU" },
  { no: 16, name: "CLIENT_VIDEO_PUBLISHER_QUALITY_LIMITATION_DURATION_OTHER" },
  { no: 4096, name: "METRIC_LABEL_PREDEFINED_MAX_VALUE" },
]);

/**
 * @generated from message livekit.MetricsBatch
 */
export class MetricsBatch extends Message<MetricsBatch> {
  /**
   * time at which this batch is sent based on a monotonic clock (millisecond resolution)
   *
   * @generated from field: int64 timestamp_ms = 1;
   */
  timestampMs = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp normalized_timestamp = 2;
   */
  normalizedTimestamp?: Timestamp;

  /**
   * To avoid repeating string values, we store them in a separate list and reference them by index
   * This is useful for storing participant identities, track names, etc.
   * There is also a predefined list of labels that can be used to reference common metrics.
   * They have reserved indices from 0 to (METRIC_LABEL_PREDEFINED_MAX_VALUE - 1).
   * Indexes pointing at str_data should start from METRIC_LABEL_PREDEFINED_MAX_VALUE, 
   * such that str_data[0] == index of METRIC_LABEL_PREDEFINED_MAX_VALUE.
   *
   * @generated from field: repeated string str_data = 3;
   */
  strData: string[] = [];

  /**
   * @generated from field: repeated livekit.TimeSeriesMetric time_series = 4;
   */
  timeSeries: TimeSeriesMetric[] = [];

  /**
   * @generated from field: repeated livekit.EventMetric events = 5;
   */
  events: EventMetric[] = [];

  constructor(data?: PartialMessage<MetricsBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "livekit.MetricsBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "str_data", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "time_series", kind: "message", T: TimeSeriesMetric, repeated: true },
    { no: 5, name: "events", kind: "message", T: EventMetric, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsBatch {
    return new MetricsBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsBatch {
    return new MetricsBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsBatch {
    return new MetricsBatch().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsBatch | PlainMessage<MetricsBatch> | undefined, b: MetricsBatch | PlainMessage<MetricsBatch> | undefined): boolean {
    return proto3.util.equals(MetricsBatch, a, b);
  }
}

/**
 * @generated from message livekit.TimeSeriesMetric
 */
export class TimeSeriesMetric extends Message<TimeSeriesMetric> {
  /**
   * Metric name e.g "speech_probablity". The string value is not directly stored in the message, but referenced by index
   * in the `str_data` field of `MetricsBatch`
   *
   * @generated from field: uint32 label = 1;
   */
  label = 0;

  /**
   * index into `str_data`
   *
   * @generated from field: uint32 participant_identity = 2;
   */
  participantIdentity = 0;

  /**
   * index into `str_data`
   *
   * @generated from field: uint32 track_sid = 3;
   */
  trackSid = 0;

  /**
   * @generated from field: repeated livekit.MetricSample samples = 4;
   */
  samples: MetricSample[] = [];

  /**
   * index into 'str_data'
   *
   * @generated from field: uint32 rid = 5;
   */
  rid = 0;

  constructor(data?: PartialMessage<TimeSeriesMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "livekit.TimeSeriesMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "participant_identity", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "track_sid", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "samples", kind: "message", T: MetricSample, repeated: true },
    { no: 5, name: "rid", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeriesMetric {
    return new TimeSeriesMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeriesMetric {
    return new TimeSeriesMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeriesMetric {
    return new TimeSeriesMetric().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeriesMetric | PlainMessage<TimeSeriesMetric> | undefined, b: TimeSeriesMetric | PlainMessage<TimeSeriesMetric> | undefined): boolean {
    return proto3.util.equals(TimeSeriesMetric, a, b);
  }
}

/**
 * @generated from message livekit.MetricSample
 */
export class MetricSample extends Message<MetricSample> {
  /**
   * time of metric based on a monotonic clock (in milliseconds)
   *
   * @generated from field: int64 timestamp_ms = 1;
   */
  timestampMs = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp normalized_timestamp = 2;
   */
  normalizedTimestamp?: Timestamp;

  /**
   * @generated from field: float value = 3;
   */
  value = 0;

  constructor(data?: PartialMessage<MetricSample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "livekit.MetricSample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "value", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricSample {
    return new MetricSample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricSample {
    return new MetricSample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricSample {
    return new MetricSample().fromJsonString(jsonString, options);
  }

  static equals(a: MetricSample | PlainMessage<MetricSample> | undefined, b: MetricSample | PlainMessage<MetricSample> | undefined): boolean {
    return proto3.util.equals(MetricSample, a, b);
  }
}

/**
 * @generated from message livekit.EventMetric
 */
export class EventMetric extends Message<EventMetric> {
  /**
   * @generated from field: uint32 label = 1;
   */
  label = 0;

  /**
   * index into `str_data`
   *
   * @generated from field: uint32 participant_identity = 2;
   */
  participantIdentity = 0;

  /**
   * index into `str_data`
   *
   * @generated from field: uint32 track_sid = 3;
   */
  trackSid = 0;

  /**
   * start time of event based on a monotonic clock (in milliseconds)
   *
   * @generated from field: int64 start_timestamp_ms = 4;
   */
  startTimestampMs = protoInt64.zero;

  /**
   * end time of event based on a monotonic clock (in milliseconds), if needed
   *
   * @generated from field: optional int64 end_timestamp_ms = 5;
   */
  endTimestampMs?: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp normalized_start_timestamp = 6;
   */
  normalizedStartTimestamp?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp normalized_end_timestamp = 7;
   */
  normalizedEndTimestamp?: Timestamp;

  /**
   * @generated from field: string metadata = 8;
   */
  metadata = "";

  /**
   * index into 'str_data'
   *
   * @generated from field: uint32 rid = 9;
   */
  rid = 0;

  constructor(data?: PartialMessage<EventMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "livekit.EventMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "participant_identity", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "track_sid", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "start_timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "end_timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 6, name: "normalized_start_timestamp", kind: "message", T: Timestamp },
    { no: 7, name: "normalized_end_timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 8, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "rid", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventMetric {
    return new EventMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventMetric {
    return new EventMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventMetric {
    return new EventMetric().fromJsonString(jsonString, options);
  }

  static equals(a: EventMetric | PlainMessage<EventMetric> | undefined, b: EventMetric | PlainMessage<EventMetric> | undefined): boolean {
    return proto3.util.equals(EventMetric, a, b);
  }
}

