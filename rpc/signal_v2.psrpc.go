// Code generated by protoc-gen-psrpc v0.6.0, DO NOT EDIT.
// source: rpc/signal_v2.proto

package rpc

import (
	"context"

	"github.com/livekit/psrpc"
	"github.com/livekit/psrpc/pkg/client"
	"github.com/livekit/psrpc/pkg/info"
	"github.com/livekit/psrpc/pkg/rand"
	"github.com/livekit/psrpc/pkg/server"
	"github.com/livekit/psrpc/version"
)

var _ = version.PsrpcVersion_0_6

// =========================
// Signalv2 Client Interface
// =========================

type Signalv2Client[NodeIdTopicType ~string] interface {
	RelaySignal(ctx context.Context, nodeId NodeIdTopicType, opts ...psrpc.RequestOption) (psrpc.ClientStream[*RelaySignalv2Request, *RelaySignalv2Response], error)

	// Close immediately, without waiting for pending RPCs
	Close()
}

// =============================
// Signalv2 ServerImpl Interface
// =============================

type Signalv2ServerImpl interface {
	RelaySignal(psrpc.ServerStream[*RelaySignalv2Response, *RelaySignalv2Request]) error
}

// =========================
// Signalv2 Server Interface
// =========================

type Signalv2Server[NodeIdTopicType ~string] interface {
	RegisterRelaySignalTopic(nodeId NodeIdTopicType) error
	DeregisterRelaySignalTopic(nodeId NodeIdTopicType)
	RegisterAllNodeTopics(nodeId NodeIdTopicType) error
	DeregisterAllNodeTopics(nodeId NodeIdTopicType)

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ===============
// Signalv2 Client
// ===============

type signalv2Client[NodeIdTopicType ~string] struct {
	client *client.RPCClient
}

// NewSignalv2Client creates a psrpc client that implements the Signalv2Client interface.
func NewSignalv2Client[NodeIdTopicType ~string](bus psrpc.MessageBus, opts ...psrpc.ClientOption) (Signalv2Client[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "Signalv2",
		ID:   rand.NewClientID(),
	}

	sd.RegisterMethod("RelaySignal", false, false, false, true)

	rpcClient, err := client.NewRPCClientWithStreams(sd, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &signalv2Client[NodeIdTopicType]{
		client: rpcClient,
	}, nil
}

func (c *signalv2Client[NodeIdTopicType]) RelaySignal(ctx context.Context, nodeId NodeIdTopicType, opts ...psrpc.RequestOption) (psrpc.ClientStream[*RelaySignalv2Request, *RelaySignalv2Response], error) {
	return client.OpenStream[*RelaySignalv2Request, *RelaySignalv2Response](ctx, c.client, "RelaySignal", []string{string(nodeId)}, opts...)
}

func (s *signalv2Client[NodeIdTopicType]) Close() {
	s.client.Close()
}

// ===============
// Signalv2 Server
// ===============

type signalv2Server[NodeIdTopicType ~string] struct {
	svc Signalv2ServerImpl
	rpc *server.RPCServer
}

// NewSignalv2Server builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewSignalv2Server[NodeIdTopicType ~string](svc Signalv2ServerImpl, bus psrpc.MessageBus, opts ...psrpc.ServerOption) (Signalv2Server[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "Signalv2",
		ID:   rand.NewServerID(),
	}

	s := server.NewRPCServer(sd, bus, opts...)

	sd.RegisterMethod("RelaySignal", false, false, false, true)
	return &signalv2Server[NodeIdTopicType]{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *signalv2Server[NodeIdTopicType]) RegisterRelaySignalTopic(nodeId NodeIdTopicType) error {
	return server.RegisterStreamHandler(s.rpc, "RelaySignal", []string{string(nodeId)}, s.svc.RelaySignal, nil)
}

func (s *signalv2Server[NodeIdTopicType]) DeregisterRelaySignalTopic(nodeId NodeIdTopicType) {
	s.rpc.DeregisterHandler("RelaySignal", []string{string(nodeId)})
}

func (s *signalv2Server[NodeIdTopicType]) allNodeTopicRegisterers() server.RegistererSlice {
	return server.RegistererSlice{
		server.NewRegisterer(s.RegisterRelaySignalTopic, s.DeregisterRelaySignalTopic),
	}
}

func (s *signalv2Server[NodeIdTopicType]) RegisterAllNodeTopics(nodeId NodeIdTopicType) error {
	return s.allNodeTopicRegisterers().Register(nodeId)
}

func (s *signalv2Server[NodeIdTopicType]) DeregisterAllNodeTopics(nodeId NodeIdTopicType) {
	s.allNodeTopicRegisterers().Deregister(nodeId)
}

func (s *signalv2Server[NodeIdTopicType]) Shutdown() {
	s.rpc.Close(false)
}

func (s *signalv2Server[NodeIdTopicType]) Kill() {
	s.rpc.Close(true)
}

var psrpcFileDescriptor10 = []byte{
	// 298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xd1, 0x4a, 0xc3, 0x30,
	0x14, 0x86, 0x89, 0x8a, 0x4a, 0xe6, 0x54, 0xb2, 0x4d, 0xb6, 0x82, 0x6c, 0xf6, 0xca, 0xab, 0x14,
	0xea, 0x9d, 0x97, 0x8a, 0xe0, 0x75, 0x7b, 0xe7, 0x4d, 0xe9, 0xb2, 0xc3, 0x0c, 0xc6, 0x24, 0xe6,
	0x64, 0x05, 0x1f, 0xc1, 0x77, 0xf0, 0x29, 0x7c, 0x42, 0x69, 0xda, 0xd9, 0x4d, 0xb6, 0x9b, 0xc2,
	0x7f, 0xce, 0x7f, 0xfe, 0xef, 0xa7, 0xa1, 0x03, 0x67, 0x45, 0x82, 0x72, 0xa9, 0x4b, 0x55, 0x54,
	0x29, 0xb7, 0xce, 0x78, 0xc3, 0x0e, 0x9d, 0x15, 0x51, 0xdf, 0x58, 0x2f, 0x8d, 0xc6, 0x66, 0x16,
	0x5d, 0x29, 0x59, 0xc1, 0x9b, 0xf4, 0x85, 0xd4, 0x1e, 0x9c, 0x2e, 0x55, 0x3b, 0x1f, 0xae, 0xe7,
	0xce, 0x8b, 0xbf, 0x84, 0xf8, 0x9b, 0xd0, 0x61, 0x06, 0xaa, 0xfc, 0xcc, 0x43, 0x74, 0x95, 0x66,
	0xf0, 0xb1, 0x02, 0xf4, 0xec, 0x9e, 0xf6, 0xd1, 0x97, 0xce, 0x17, 0x08, 0x88, 0xd2, 0xe8, 0x31,
	0x99, 0x91, 0xdb, 0x5e, 0x3a, 0xe2, 0x6d, 0x0c, 0xcf, 0xeb, 0x6d, 0xde, 0x2c, 0xb3, 0x33, 0xdc,
	0x50, 0xec, 0x99, 0x5e, 0x08, 0x25, 0x41, 0xfb, 0x02, 0x74, 0x05, 0xca, 0x58, 0x18, 0x1f, 0x84,
	0xeb, 0x69, 0x77, 0xdd, 0xe2, 0x1e, 0x83, 0xef, 0xa9, 0xb5, 0x65, 0xe7, 0x62, 0x4b, 0xc7, 0x25,
	0x1d, 0xfd, 0x6b, 0x87, 0xd6, 0x68, 0x84, 0x1a, 0x81, 0xe0, 0x2a, 0x70, 0x1d, 0x82, 0xec, 0x41,
	0xe4, 0xc1, 0xd7, 0x21, 0x70, 0x4b, 0xa7, 0x86, 0x9e, 0xae, 0x9d, 0x4c, 0xd0, 0xde, 0x06, 0x8e,
	0x4d, 0xb8, 0xb3, 0x82, 0xef, 0xfa, 0x3d, 0x51, 0xb4, 0x6b, 0xd5, 0x74, 0x8b, 0xaf, 0x7f, 0xbe,
	0xc8, 0xe4, 0x92, 0x44, 0x03, 0x7a, 0xa4, 0xcd, 0x02, 0xd8, 0x49, 0xfd, 0x2d, 0xe4, 0xa2, 0x6e,
	0x38, 0x23, 0x0f, 0x37, 0x2f, 0xd3, 0xa5, 0xf4, 0xaf, 0xab, 0x39, 0x17, 0xe6, 0x3d, 0x69, 0xdb,
	0x26, 0xe1, 0x39, 0x84, 0x51, 0x89, 0xb3, 0x62, 0x7e, 0x1c, 0xd4, 0xdd, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x81, 0x36, 0xe7, 0xfa, 0xf5, 0x01, 0x00, 0x00,
}
