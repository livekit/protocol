// Code generated by counterfeiter. DO NOT EDIT.
package rpcfakes

import (
	"context"
	"sync"

	"github.com/livekit/protocol/livekit"
	"github.com/livekit/protocol/rpc"
	"github.com/livekit/psrpc"
)

type FakeTypedRoomClient struct {
	DeleteRoomStub        func(context.Context, rpc.RoomTopic, *livekit.DeleteRoomRequest, ...psrpc.RequestOption) (*livekit.DeleteRoomResponse, error)
	deleteRoomMutex       sync.RWMutex
	deleteRoomArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.DeleteRoomRequest
		arg4 []psrpc.RequestOption
	}
	deleteRoomReturns struct {
		result1 *livekit.DeleteRoomResponse
		result2 error
	}
	deleteRoomReturnsOnCall map[int]struct {
		result1 *livekit.DeleteRoomResponse
		result2 error
	}
	MutePublishedTrackStub        func(context.Context, rpc.ParticipantTopic, *livekit.MuteRoomTrackRequest, ...psrpc.RequestOption) (*livekit.MuteRoomTrackResponse, error)
	mutePublishedTrackMutex       sync.RWMutex
	mutePublishedTrackArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.MuteRoomTrackRequest
		arg4 []psrpc.RequestOption
	}
	mutePublishedTrackReturns struct {
		result1 *livekit.MuteRoomTrackResponse
		result2 error
	}
	mutePublishedTrackReturnsOnCall map[int]struct {
		result1 *livekit.MuteRoomTrackResponse
		result2 error
	}
	RemoveParticipantStub        func(context.Context, rpc.ParticipantTopic, *livekit.RoomParticipantIdentity, ...psrpc.RequestOption) (*livekit.RemoveParticipantResponse, error)
	removeParticipantMutex       sync.RWMutex
	removeParticipantArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.RoomParticipantIdentity
		arg4 []psrpc.RequestOption
	}
	removeParticipantReturns struct {
		result1 *livekit.RemoveParticipantResponse
		result2 error
	}
	removeParticipantReturnsOnCall map[int]struct {
		result1 *livekit.RemoveParticipantResponse
		result2 error
	}
	SendDataStub        func(context.Context, rpc.RoomTopic, *livekit.SendDataRequest, ...psrpc.RequestOption) (*livekit.SendDataResponse, error)
	sendDataMutex       sync.RWMutex
	sendDataArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.SendDataRequest
		arg4 []psrpc.RequestOption
	}
	sendDataReturns struct {
		result1 *livekit.SendDataResponse
		result2 error
	}
	sendDataReturnsOnCall map[int]struct {
		result1 *livekit.SendDataResponse
		result2 error
	}
	UpdateParticipantStub        func(context.Context, rpc.ParticipantTopic, *livekit.UpdateParticipantRequest, ...psrpc.RequestOption) (*livekit.ParticipantInfo, error)
	updateParticipantMutex       sync.RWMutex
	updateParticipantArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.UpdateParticipantRequest
		arg4 []psrpc.RequestOption
	}
	updateParticipantReturns struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}
	updateParticipantReturnsOnCall map[int]struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}
	UpdateRoomMetadataStub        func(context.Context, rpc.RoomTopic, *livekit.UpdateRoomMetadataRequest, ...psrpc.RequestOption) (*livekit.Room, error)
	updateRoomMetadataMutex       sync.RWMutex
	updateRoomMetadataArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.UpdateRoomMetadataRequest
		arg4 []psrpc.RequestOption
	}
	updateRoomMetadataReturns struct {
		result1 *livekit.Room
		result2 error
	}
	updateRoomMetadataReturnsOnCall map[int]struct {
		result1 *livekit.Room
		result2 error
	}
	UpdateSubscriptionsStub        func(context.Context, rpc.ParticipantTopic, *livekit.UpdateSubscriptionsRequest, ...psrpc.RequestOption) (*livekit.UpdateSubscriptionsResponse, error)
	updateSubscriptionsMutex       sync.RWMutex
	updateSubscriptionsArgsForCall []struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.UpdateSubscriptionsRequest
		arg4 []psrpc.RequestOption
	}
	updateSubscriptionsReturns struct {
		result1 *livekit.UpdateSubscriptionsResponse
		result2 error
	}
	updateSubscriptionsReturnsOnCall map[int]struct {
		result1 *livekit.UpdateSubscriptionsResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTypedRoomClient) DeleteRoom(arg1 context.Context, arg2 rpc.RoomTopic, arg3 *livekit.DeleteRoomRequest, arg4 ...psrpc.RequestOption) (*livekit.DeleteRoomResponse, error) {
	fake.deleteRoomMutex.Lock()
	ret, specificReturn := fake.deleteRoomReturnsOnCall[len(fake.deleteRoomArgsForCall)]
	fake.deleteRoomArgsForCall = append(fake.deleteRoomArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.DeleteRoomRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteRoomStub
	fakeReturns := fake.deleteRoomReturns
	fake.recordInvocation("DeleteRoom", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) DeleteRoomCallCount() int {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	return len(fake.deleteRoomArgsForCall)
}

func (fake *FakeTypedRoomClient) DeleteRoomCalls(stub func(context.Context, rpc.RoomTopic, *livekit.DeleteRoomRequest, ...psrpc.RequestOption) (*livekit.DeleteRoomResponse, error)) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = stub
}

func (fake *FakeTypedRoomClient) DeleteRoomArgsForCall(i int) (context.Context, rpc.RoomTopic, *livekit.DeleteRoomRequest, []psrpc.RequestOption) {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	argsForCall := fake.deleteRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) DeleteRoomReturns(result1 *livekit.DeleteRoomResponse, result2 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	fake.deleteRoomReturns = struct {
		result1 *livekit.DeleteRoomResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) DeleteRoomReturnsOnCall(i int, result1 *livekit.DeleteRoomResponse, result2 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	if fake.deleteRoomReturnsOnCall == nil {
		fake.deleteRoomReturnsOnCall = make(map[int]struct {
			result1 *livekit.DeleteRoomResponse
			result2 error
		})
	}
	fake.deleteRoomReturnsOnCall[i] = struct {
		result1 *livekit.DeleteRoomResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) MutePublishedTrack(arg1 context.Context, arg2 rpc.ParticipantTopic, arg3 *livekit.MuteRoomTrackRequest, arg4 ...psrpc.RequestOption) (*livekit.MuteRoomTrackResponse, error) {
	fake.mutePublishedTrackMutex.Lock()
	ret, specificReturn := fake.mutePublishedTrackReturnsOnCall[len(fake.mutePublishedTrackArgsForCall)]
	fake.mutePublishedTrackArgsForCall = append(fake.mutePublishedTrackArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.MuteRoomTrackRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.MutePublishedTrackStub
	fakeReturns := fake.mutePublishedTrackReturns
	fake.recordInvocation("MutePublishedTrack", []interface{}{arg1, arg2, arg3, arg4})
	fake.mutePublishedTrackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) MutePublishedTrackCallCount() int {
	fake.mutePublishedTrackMutex.RLock()
	defer fake.mutePublishedTrackMutex.RUnlock()
	return len(fake.mutePublishedTrackArgsForCall)
}

func (fake *FakeTypedRoomClient) MutePublishedTrackCalls(stub func(context.Context, rpc.ParticipantTopic, *livekit.MuteRoomTrackRequest, ...psrpc.RequestOption) (*livekit.MuteRoomTrackResponse, error)) {
	fake.mutePublishedTrackMutex.Lock()
	defer fake.mutePublishedTrackMutex.Unlock()
	fake.MutePublishedTrackStub = stub
}

func (fake *FakeTypedRoomClient) MutePublishedTrackArgsForCall(i int) (context.Context, rpc.ParticipantTopic, *livekit.MuteRoomTrackRequest, []psrpc.RequestOption) {
	fake.mutePublishedTrackMutex.RLock()
	defer fake.mutePublishedTrackMutex.RUnlock()
	argsForCall := fake.mutePublishedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) MutePublishedTrackReturns(result1 *livekit.MuteRoomTrackResponse, result2 error) {
	fake.mutePublishedTrackMutex.Lock()
	defer fake.mutePublishedTrackMutex.Unlock()
	fake.MutePublishedTrackStub = nil
	fake.mutePublishedTrackReturns = struct {
		result1 *livekit.MuteRoomTrackResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) MutePublishedTrackReturnsOnCall(i int, result1 *livekit.MuteRoomTrackResponse, result2 error) {
	fake.mutePublishedTrackMutex.Lock()
	defer fake.mutePublishedTrackMutex.Unlock()
	fake.MutePublishedTrackStub = nil
	if fake.mutePublishedTrackReturnsOnCall == nil {
		fake.mutePublishedTrackReturnsOnCall = make(map[int]struct {
			result1 *livekit.MuteRoomTrackResponse
			result2 error
		})
	}
	fake.mutePublishedTrackReturnsOnCall[i] = struct {
		result1 *livekit.MuteRoomTrackResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) RemoveParticipant(arg1 context.Context, arg2 rpc.ParticipantTopic, arg3 *livekit.RoomParticipantIdentity, arg4 ...psrpc.RequestOption) (*livekit.RemoveParticipantResponse, error) {
	fake.removeParticipantMutex.Lock()
	ret, specificReturn := fake.removeParticipantReturnsOnCall[len(fake.removeParticipantArgsForCall)]
	fake.removeParticipantArgsForCall = append(fake.removeParticipantArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.RoomParticipantIdentity
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveParticipantStub
	fakeReturns := fake.removeParticipantReturns
	fake.recordInvocation("RemoveParticipant", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeParticipantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) RemoveParticipantCallCount() int {
	fake.removeParticipantMutex.RLock()
	defer fake.removeParticipantMutex.RUnlock()
	return len(fake.removeParticipantArgsForCall)
}

func (fake *FakeTypedRoomClient) RemoveParticipantCalls(stub func(context.Context, rpc.ParticipantTopic, *livekit.RoomParticipantIdentity, ...psrpc.RequestOption) (*livekit.RemoveParticipantResponse, error)) {
	fake.removeParticipantMutex.Lock()
	defer fake.removeParticipantMutex.Unlock()
	fake.RemoveParticipantStub = stub
}

func (fake *FakeTypedRoomClient) RemoveParticipantArgsForCall(i int) (context.Context, rpc.ParticipantTopic, *livekit.RoomParticipantIdentity, []psrpc.RequestOption) {
	fake.removeParticipantMutex.RLock()
	defer fake.removeParticipantMutex.RUnlock()
	argsForCall := fake.removeParticipantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) RemoveParticipantReturns(result1 *livekit.RemoveParticipantResponse, result2 error) {
	fake.removeParticipantMutex.Lock()
	defer fake.removeParticipantMutex.Unlock()
	fake.RemoveParticipantStub = nil
	fake.removeParticipantReturns = struct {
		result1 *livekit.RemoveParticipantResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) RemoveParticipantReturnsOnCall(i int, result1 *livekit.RemoveParticipantResponse, result2 error) {
	fake.removeParticipantMutex.Lock()
	defer fake.removeParticipantMutex.Unlock()
	fake.RemoveParticipantStub = nil
	if fake.removeParticipantReturnsOnCall == nil {
		fake.removeParticipantReturnsOnCall = make(map[int]struct {
			result1 *livekit.RemoveParticipantResponse
			result2 error
		})
	}
	fake.removeParticipantReturnsOnCall[i] = struct {
		result1 *livekit.RemoveParticipantResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) SendData(arg1 context.Context, arg2 rpc.RoomTopic, arg3 *livekit.SendDataRequest, arg4 ...psrpc.RequestOption) (*livekit.SendDataResponse, error) {
	fake.sendDataMutex.Lock()
	ret, specificReturn := fake.sendDataReturnsOnCall[len(fake.sendDataArgsForCall)]
	fake.sendDataArgsForCall = append(fake.sendDataArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.SendDataRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.SendDataStub
	fakeReturns := fake.sendDataReturns
	fake.recordInvocation("SendData", []interface{}{arg1, arg2, arg3, arg4})
	fake.sendDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) SendDataCallCount() int {
	fake.sendDataMutex.RLock()
	defer fake.sendDataMutex.RUnlock()
	return len(fake.sendDataArgsForCall)
}

func (fake *FakeTypedRoomClient) SendDataCalls(stub func(context.Context, rpc.RoomTopic, *livekit.SendDataRequest, ...psrpc.RequestOption) (*livekit.SendDataResponse, error)) {
	fake.sendDataMutex.Lock()
	defer fake.sendDataMutex.Unlock()
	fake.SendDataStub = stub
}

func (fake *FakeTypedRoomClient) SendDataArgsForCall(i int) (context.Context, rpc.RoomTopic, *livekit.SendDataRequest, []psrpc.RequestOption) {
	fake.sendDataMutex.RLock()
	defer fake.sendDataMutex.RUnlock()
	argsForCall := fake.sendDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) SendDataReturns(result1 *livekit.SendDataResponse, result2 error) {
	fake.sendDataMutex.Lock()
	defer fake.sendDataMutex.Unlock()
	fake.SendDataStub = nil
	fake.sendDataReturns = struct {
		result1 *livekit.SendDataResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) SendDataReturnsOnCall(i int, result1 *livekit.SendDataResponse, result2 error) {
	fake.sendDataMutex.Lock()
	defer fake.sendDataMutex.Unlock()
	fake.SendDataStub = nil
	if fake.sendDataReturnsOnCall == nil {
		fake.sendDataReturnsOnCall = make(map[int]struct {
			result1 *livekit.SendDataResponse
			result2 error
		})
	}
	fake.sendDataReturnsOnCall[i] = struct {
		result1 *livekit.SendDataResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateParticipant(arg1 context.Context, arg2 rpc.ParticipantTopic, arg3 *livekit.UpdateParticipantRequest, arg4 ...psrpc.RequestOption) (*livekit.ParticipantInfo, error) {
	fake.updateParticipantMutex.Lock()
	ret, specificReturn := fake.updateParticipantReturnsOnCall[len(fake.updateParticipantArgsForCall)]
	fake.updateParticipantArgsForCall = append(fake.updateParticipantArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.UpdateParticipantRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateParticipantStub
	fakeReturns := fake.updateParticipantReturns
	fake.recordInvocation("UpdateParticipant", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateParticipantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) UpdateParticipantCallCount() int {
	fake.updateParticipantMutex.RLock()
	defer fake.updateParticipantMutex.RUnlock()
	return len(fake.updateParticipantArgsForCall)
}

func (fake *FakeTypedRoomClient) UpdateParticipantCalls(stub func(context.Context, rpc.ParticipantTopic, *livekit.UpdateParticipantRequest, ...psrpc.RequestOption) (*livekit.ParticipantInfo, error)) {
	fake.updateParticipantMutex.Lock()
	defer fake.updateParticipantMutex.Unlock()
	fake.UpdateParticipantStub = stub
}

func (fake *FakeTypedRoomClient) UpdateParticipantArgsForCall(i int) (context.Context, rpc.ParticipantTopic, *livekit.UpdateParticipantRequest, []psrpc.RequestOption) {
	fake.updateParticipantMutex.RLock()
	defer fake.updateParticipantMutex.RUnlock()
	argsForCall := fake.updateParticipantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) UpdateParticipantReturns(result1 *livekit.ParticipantInfo, result2 error) {
	fake.updateParticipantMutex.Lock()
	defer fake.updateParticipantMutex.Unlock()
	fake.UpdateParticipantStub = nil
	fake.updateParticipantReturns = struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateParticipantReturnsOnCall(i int, result1 *livekit.ParticipantInfo, result2 error) {
	fake.updateParticipantMutex.Lock()
	defer fake.updateParticipantMutex.Unlock()
	fake.UpdateParticipantStub = nil
	if fake.updateParticipantReturnsOnCall == nil {
		fake.updateParticipantReturnsOnCall = make(map[int]struct {
			result1 *livekit.ParticipantInfo
			result2 error
		})
	}
	fake.updateParticipantReturnsOnCall[i] = struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadata(arg1 context.Context, arg2 rpc.RoomTopic, arg3 *livekit.UpdateRoomMetadataRequest, arg4 ...psrpc.RequestOption) (*livekit.Room, error) {
	fake.updateRoomMetadataMutex.Lock()
	ret, specificReturn := fake.updateRoomMetadataReturnsOnCall[len(fake.updateRoomMetadataArgsForCall)]
	fake.updateRoomMetadataArgsForCall = append(fake.updateRoomMetadataArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.RoomTopic
		arg3 *livekit.UpdateRoomMetadataRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateRoomMetadataStub
	fakeReturns := fake.updateRoomMetadataReturns
	fake.recordInvocation("UpdateRoomMetadata", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateRoomMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadataCallCount() int {
	fake.updateRoomMetadataMutex.RLock()
	defer fake.updateRoomMetadataMutex.RUnlock()
	return len(fake.updateRoomMetadataArgsForCall)
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadataCalls(stub func(context.Context, rpc.RoomTopic, *livekit.UpdateRoomMetadataRequest, ...psrpc.RequestOption) (*livekit.Room, error)) {
	fake.updateRoomMetadataMutex.Lock()
	defer fake.updateRoomMetadataMutex.Unlock()
	fake.UpdateRoomMetadataStub = stub
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadataArgsForCall(i int) (context.Context, rpc.RoomTopic, *livekit.UpdateRoomMetadataRequest, []psrpc.RequestOption) {
	fake.updateRoomMetadataMutex.RLock()
	defer fake.updateRoomMetadataMutex.RUnlock()
	argsForCall := fake.updateRoomMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadataReturns(result1 *livekit.Room, result2 error) {
	fake.updateRoomMetadataMutex.Lock()
	defer fake.updateRoomMetadataMutex.Unlock()
	fake.UpdateRoomMetadataStub = nil
	fake.updateRoomMetadataReturns = struct {
		result1 *livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateRoomMetadataReturnsOnCall(i int, result1 *livekit.Room, result2 error) {
	fake.updateRoomMetadataMutex.Lock()
	defer fake.updateRoomMetadataMutex.Unlock()
	fake.UpdateRoomMetadataStub = nil
	if fake.updateRoomMetadataReturnsOnCall == nil {
		fake.updateRoomMetadataReturnsOnCall = make(map[int]struct {
			result1 *livekit.Room
			result2 error
		})
	}
	fake.updateRoomMetadataReturnsOnCall[i] = struct {
		result1 *livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateSubscriptions(arg1 context.Context, arg2 rpc.ParticipantTopic, arg3 *livekit.UpdateSubscriptionsRequest, arg4 ...psrpc.RequestOption) (*livekit.UpdateSubscriptionsResponse, error) {
	fake.updateSubscriptionsMutex.Lock()
	ret, specificReturn := fake.updateSubscriptionsReturnsOnCall[len(fake.updateSubscriptionsArgsForCall)]
	fake.updateSubscriptionsArgsForCall = append(fake.updateSubscriptionsArgsForCall, struct {
		arg1 context.Context
		arg2 rpc.ParticipantTopic
		arg3 *livekit.UpdateSubscriptionsRequest
		arg4 []psrpc.RequestOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateSubscriptionsStub
	fakeReturns := fake.updateSubscriptionsReturns
	fake.recordInvocation("UpdateSubscriptions", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateSubscriptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTypedRoomClient) UpdateSubscriptionsCallCount() int {
	fake.updateSubscriptionsMutex.RLock()
	defer fake.updateSubscriptionsMutex.RUnlock()
	return len(fake.updateSubscriptionsArgsForCall)
}

func (fake *FakeTypedRoomClient) UpdateSubscriptionsCalls(stub func(context.Context, rpc.ParticipantTopic, *livekit.UpdateSubscriptionsRequest, ...psrpc.RequestOption) (*livekit.UpdateSubscriptionsResponse, error)) {
	fake.updateSubscriptionsMutex.Lock()
	defer fake.updateSubscriptionsMutex.Unlock()
	fake.UpdateSubscriptionsStub = stub
}

func (fake *FakeTypedRoomClient) UpdateSubscriptionsArgsForCall(i int) (context.Context, rpc.ParticipantTopic, *livekit.UpdateSubscriptionsRequest, []psrpc.RequestOption) {
	fake.updateSubscriptionsMutex.RLock()
	defer fake.updateSubscriptionsMutex.RUnlock()
	argsForCall := fake.updateSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTypedRoomClient) UpdateSubscriptionsReturns(result1 *livekit.UpdateSubscriptionsResponse, result2 error) {
	fake.updateSubscriptionsMutex.Lock()
	defer fake.updateSubscriptionsMutex.Unlock()
	fake.UpdateSubscriptionsStub = nil
	fake.updateSubscriptionsReturns = struct {
		result1 *livekit.UpdateSubscriptionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) UpdateSubscriptionsReturnsOnCall(i int, result1 *livekit.UpdateSubscriptionsResponse, result2 error) {
	fake.updateSubscriptionsMutex.Lock()
	defer fake.updateSubscriptionsMutex.Unlock()
	fake.UpdateSubscriptionsStub = nil
	if fake.updateSubscriptionsReturnsOnCall == nil {
		fake.updateSubscriptionsReturnsOnCall = make(map[int]struct {
			result1 *livekit.UpdateSubscriptionsResponse
			result2 error
		})
	}
	fake.updateSubscriptionsReturnsOnCall[i] = struct {
		result1 *livekit.UpdateSubscriptionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTypedRoomClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	fake.mutePublishedTrackMutex.RLock()
	defer fake.mutePublishedTrackMutex.RUnlock()
	fake.removeParticipantMutex.RLock()
	defer fake.removeParticipantMutex.RUnlock()
	fake.sendDataMutex.RLock()
	defer fake.sendDataMutex.RUnlock()
	fake.updateParticipantMutex.RLock()
	defer fake.updateParticipantMutex.RUnlock()
	fake.updateRoomMetadataMutex.RLock()
	defer fake.updateRoomMetadataMutex.RUnlock()
	fake.updateSubscriptionsMutex.RLock()
	defer fake.updateSubscriptionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTypedRoomClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rpc.TypedRoomClient = new(FakeTypedRoomClient)
