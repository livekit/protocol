// Code generated by protoc-gen-psrpc v0.3.0, DO NOT EDIT.
// source: rpc/ingress.proto

package rpc

import (
	"context"

	"github.com/livekit/psrpc"
	"github.com/livekit/psrpc/pkg/client"
	"github.com/livekit/psrpc/pkg/info"
	"github.com/livekit/psrpc/pkg/server"
	"github.com/livekit/psrpc/version"
)
import google_protobuf3 "google.golang.org/protobuf/types/known/emptypb"
import livekit2 "github.com/livekit/protocol/livekit"

var _ = version.PsrpcVersion_0_3_0

// ================================
// IngressInternal Client Interface
// ================================

type IngressInternalClient interface {
	StartIngress(ctx context.Context, opts ...psrpc.RequestOption) (psrpc.ClientStream[*StartIngressRequest, *livekit2.IngressInfo], error)

	ListActiveIngress(ctx context.Context, req *ListActiveIngressRequest, opts ...psrpc.RequestOption) (*ListActiveIngressResponse, error)
}

// ====================================
// IngressInternal ServerImpl Interface
// ====================================

type IngressInternalServerImpl interface {
	StartIngress(psrpc.ServerStream[*livekit2.IngressInfo, *StartIngressRequest]) error

	ListActiveIngress(context.Context, *ListActiveIngressRequest) (*ListActiveIngressResponse, error)
	ListActiveIngressAffinity(*ListActiveIngressRequest) float32
}

// ================================
// IngressInternal Server Interface
// ================================

type IngressInternalServer interface {

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ======================
// IngressInternal Client
// ======================

type ingressInternalClient struct {
	client *client.RPCClient
}

// NewIngressInternalClient creates a psrpc client that implements the IngressInternalClient interface.
func NewIngressInternalClient(clientID string, bus psrpc.MessageBus, opts ...psrpc.ClientOption) (IngressInternalClient, error) {
	sd := &info.ServiceDefinition{
		Name: "IngressInternal",
		ID:   clientID,
	}

	sd.RegisterMethod("StartIngress", false, false, true)
	sd.RegisterMethod("ListActiveIngress", true, false, true)

	rpcClient, err := client.NewRPCClientWithStreams(sd, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressInternalClient{
		client: rpcClient,
	}, nil
}

func (c *ingressInternalClient) StartIngress(ctx context.Context, opts ...psrpc.RequestOption) (psrpc.ClientStream[*StartIngressRequest, *livekit2.IngressInfo], error) {
	return client.OpenStream[*StartIngressRequest, *livekit2.IngressInfo](ctx, c.client, "StartIngress", nil, opts...)
}

func (c *ingressInternalClient) ListActiveIngress(ctx context.Context, req *ListActiveIngressRequest, opts ...psrpc.RequestOption) (*ListActiveIngressResponse, error) {
	return client.RequestSingle[*ListActiveIngressResponse](ctx, c.client, "ListActiveIngress", nil, req, opts...)
}

// ======================
// IngressInternal Server
// ======================

type ingressInternalServer struct {
	svc IngressInternalServerImpl
	rpc *server.RPCServer
}

// NewIngressInternalServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressInternalServer(serverID string, svc IngressInternalServerImpl, bus psrpc.MessageBus, opts ...psrpc.ServerOption) (IngressInternalServer, error) {
	sd := &info.ServiceDefinition{
		Name: "IngressInternal",
		ID:   serverID,
	}

	s := server.NewRPCServer(sd, bus, opts...)

	sd.RegisterMethod("StartIngress", false, false, true)
	var err error
	err = server.RegisterStreamHandler(s, "StartIngress", nil, svc.StartIngress, nil)
	if err != nil {
		s.Close(false)
		return nil, err
	}

	sd.RegisterMethod("ListActiveIngress", true, false, true)
	err = server.RegisterHandler(s, "ListActiveIngress", nil, svc.ListActiveIngress, svc.ListActiveIngressAffinity)
	if err != nil {
		s.Close(false)
		return nil, err
	}

	return &ingressInternalServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressInternalServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressInternalServer) Kill() {
	s.rpc.Close(true)
}

// ===============================
// IngressHandler Client Interface
// ===============================

type IngressHandlerClient interface {
	SubscribeUpdateIngress(ctx context.Context) (psrpc.Subscription[*livekit2.IngressState], error)

	SubscribeDeleteIngress(ctx context.Context) (psrpc.Subscription[*livekit2.IngressState], error)

	SubscribeDeleteWHIPResource(ctx context.Context) (psrpc.Subscription[*google_protobuf3.Empty], error)
}

// ===================================
// IngressHandler ServerImpl Interface
// ===================================

type IngressHandlerServerImpl interface {
}

// ===============================
// IngressHandler Server Interface
// ===============================

type IngressHandlerServer interface {
	PublishUpdateIngress(ctx context.Context, msg *livekit2.IngressState) error

	PublishDeleteIngress(ctx context.Context, msg *livekit2.IngressState) error

	PublishDeleteWHIPResource(ctx context.Context, msg *google_protobuf3.Empty) error

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// =====================
// IngressHandler Client
// =====================

type ingressHandlerClient struct {
	client *client.RPCClient
}

// NewIngressHandlerClient creates a psrpc client that implements the IngressHandlerClient interface.
func NewIngressHandlerClient(clientID string, bus psrpc.MessageBus, opts ...psrpc.ClientOption) (IngressHandlerClient, error) {
	sd := &info.ServiceDefinition{
		Name: "IngressHandler",
		ID:   clientID,
	}

	sd.RegisterMethod("UpdateIngress", false, false, true)
	sd.RegisterMethod("DeleteIngress", false, false, true)
	sd.RegisterMethod("DeleteWHIPResource", false, false, true)

	rpcClient, err := client.NewRPCClient(sd, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressHandlerClient{
		client: rpcClient,
	}, nil
}

func (c *ingressHandlerClient) SubscribeUpdateIngress(ctx context.Context) (psrpc.Subscription[*livekit2.IngressState], error) {
	return client.JoinQueue[*livekit2.IngressState](ctx, c.client, "UpdateIngress", nil)
}

func (c *ingressHandlerClient) SubscribeDeleteIngress(ctx context.Context) (psrpc.Subscription[*livekit2.IngressState], error) {
	return client.JoinQueue[*livekit2.IngressState](ctx, c.client, "DeleteIngress", nil)
}

func (c *ingressHandlerClient) SubscribeDeleteWHIPResource(ctx context.Context) (psrpc.Subscription[*google_protobuf3.Empty], error) {
	return client.JoinQueue[*google_protobuf3.Empty](ctx, c.client, "DeleteWHIPResource", nil)
}

// =====================
// IngressHandler Server
// =====================

type ingressHandlerServer struct {
	svc IngressHandlerServerImpl
	rpc *server.RPCServer
}

// NewIngressHandlerServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressHandlerServer(serverID string, svc IngressHandlerServerImpl, bus psrpc.MessageBus, opts ...psrpc.ServerOption) (IngressHandlerServer, error) {
	sd := &info.ServiceDefinition{
		Name: "IngressHandler",
		ID:   serverID,
	}

	s := server.NewRPCServer(sd, bus, opts...)

	sd.RegisterMethod("UpdateIngress", false, false, true)
	sd.RegisterMethod("DeleteIngress", false, false, true)
	sd.RegisterMethod("DeleteWHIPResource", false, false, true)
	return &ingressHandlerServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressHandlerServer) PublishUpdateIngress(ctx context.Context, msg *livekit2.IngressState) error {
	return s.rpc.Publish(ctx, "UpdateIngress", nil, msg)
}

func (s *ingressHandlerServer) PublishDeleteIngress(ctx context.Context, msg *livekit2.IngressState) error {
	return s.rpc.Publish(ctx, "DeleteIngress", nil, msg)
}

func (s *ingressHandlerServer) PublishDeleteWHIPResource(ctx context.Context, msg *google_protobuf3.Empty) error {
	return s.rpc.Publish(ctx, "DeleteWHIPResource", nil, msg)
}

func (s *ingressHandlerServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressHandlerServer) Kill() {
	s.rpc.Close(true)
}

var psrpcFileDescriptor1 = []byte{
	// 441 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xc1, 0x8b, 0xd3, 0x40,
	0x14, 0xc6, 0x49, 0xab, 0x85, 0x7d, 0xeb, 0xaa, 0x3b, 0x6e, 0x25, 0x1b, 0x59, 0x5d, 0x72, 0x2a,
	0x22, 0x13, 0xa9, 0x57, 0x2f, 0x8a, 0xca, 0x06, 0x15, 0xa4, 0xeb, 0x22, 0xac, 0x87, 0x90, 0x26,
	0xaf, 0x71, 0x68, 0x9a, 0x19, 0x67, 0x5e, 0xba, 0xf4, 0xee, 0xc5, 0x7f, 0x47, 0xf0, 0xff, 0x93,
	0x66, 0x26, 0xcb, 0xc6, 0xb6, 0xb0, 0xa7, 0x30, 0xdf, 0x9b, 0xf7, 0x7b, 0x5f, 0xe6, 0x7d, 0x70,
	0xa8, 0x55, 0x16, 0x89, 0xaa, 0xd0, 0x68, 0x0c, 0x57, 0x5a, 0x92, 0x64, 0x7d, 0xad, 0xb2, 0xe0,
	0x40, 0x2a, 0x12, 0xb2, 0x72, 0x5a, 0x30, 0x2c, 0xc5, 0x12, 0xe7, 0x82, 0x92, 0xce, 0xd5, 0xe0,
	0x49, 0x21, 0x65, 0x51, 0x62, 0xd4, 0x9c, 0xa6, 0xf5, 0x2c, 0xc2, 0x85, 0xa2, 0x95, 0x2d, 0x86,
	0x01, 0xf8, 0x9f, 0x84, 0xa1, 0x37, 0x19, 0x89, 0x25, 0xc6, 0xb6, 0x6f, 0x82, 0x3f, 0x6b, 0x34,
	0x14, 0xbe, 0x86, 0xe3, 0x2d, 0x35, 0xa3, 0x64, 0x65, 0x90, 0x3d, 0x83, 0x7d, 0x37, 0x26, 0x11,
	0xb9, 0xf1, 0xbd, 0xd3, 0xfe, 0x68, 0x6f, 0x02, 0x4e, 0x8a, 0x73, 0x13, 0x7e, 0x87, 0xe3, 0x77,
	0x58, 0x22, 0xe1, 0xb7, 0xb3, 0xf8, 0xcb, 0x04, 0x8d, 0xac, 0x75, 0x86, 0x0e, 0xbd, 0xee, 0xd6,
	0x4e, 0x4a, 0x44, 0xee, 0x7b, 0xa7, 0xde, 0xba, 0xbb, 0x95, 0xe2, 0x9c, 0x9d, 0x00, 0x18, 0xd2,
	0x98, 0x2e, 0x92, 0x39, 0xae, 0xfc, 0x5e, 0x53, 0xdf, 0xb3, 0xca, 0x47, 0x5c, 0x85, 0x25, 0x3c,
	0x3a, 0xa7, 0x54, 0x53, 0xd7, 0x31, 0x1b, 0xc1, 0x1d, 0x51, 0xcd, 0x64, 0xc3, 0xdb, 0x1f, 0x1f,
	0x71, 0xf7, 0x20, 0xdc, 0x5d, 0x8b, 0xab, 0x99, 0x9c, 0x34, 0x37, 0xd8, 0x11, 0xdc, 0x25, 0x39,
	0xc7, 0xca, 0xa1, 0xed, 0x81, 0x0d, 0x61, 0x70, 0x65, 0x92, 0x5a, 0x97, 0x7e, 0xdf, 0xca, 0x57,
	0xe6, 0x42, 0x97, 0xe3, 0xbf, 0x1e, 0x3c, 0xb8, 0x46, 0x10, 0xea, 0x2a, 0x2d, 0xd9, 0x07, 0xb8,
	0x77, 0xd3, 0x01, 0xf3, 0xb9, 0x56, 0x19, 0xdf, 0x62, 0x2a, 0xd8, 0x6a, 0x23, 0x1c, 0xfc, 0xf9,
	0xed, 0xf5, 0x5e, 0x7a, 0xec, 0x12, 0x0e, 0x37, 0x1e, 0x99, 0x9d, 0x34, 0xb0, 0x5d, 0x8b, 0x09,
	0x9e, 0xee, 0x2a, 0xdb, 0xdd, 0x58, 0xf6, 0xc8, 0x1b, 0xff, 0xea, 0xc1, 0x7d, 0x57, 0x3b, 0x4b,
	0xab, 0xbc, 0x44, 0xcd, 0x3e, 0xc3, 0xc1, 0x85, 0xca, 0x53, 0xba, 0x31, 0xaa, 0x75, 0xd7, 0xd1,
	0xdb, 0x51, 0xc3, 0xff, 0xcd, 0x9f, 0x53, 0x4a, 0x6e, 0xc2, 0x43, 0x6f, 0x8d, 0xb3, 0x4b, 0xde,
	0xc4, 0x75, 0xf4, 0x5b, 0xe2, 0xbe, 0x02, 0xdb, 0xcc, 0x0c, 0xb3, 0xbf, 0xbb, 0x33, 0x4c, 0xc1,
	0x63, 0x6e, 0x13, 0xce, 0xdb, 0x84, 0xf3, 0xf7, 0xeb, 0x84, 0xb7, 0xd4, 0xb7, 0x2f, 0x2e, 0x9f,
	0x17, 0x82, 0x7e, 0xd4, 0x53, 0x9e, 0xc9, 0x45, 0xe4, 0x0c, 0x5c, 0x7f, 0xd5, 0xbc, 0x88, 0x0c,
	0xea, 0xa5, 0xc8, 0x30, 0xd2, 0x2a, 0x9b, 0x0e, 0x1a, 0xca, 0xab, 0x7f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x42, 0xc5, 0x0d, 0x06, 0x75, 0x03, 0x00, 0x00,
}
